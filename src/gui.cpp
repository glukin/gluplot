// generated by Fast Light User Interface Designer (fluid) version 1.0107

#include "gui.h"

void glpUI::cb_Clear_i(Fl_Menu_*, void*) {
  ((glp::plot*)pout)->clear();
pout->redraw();
}
void glpUI::cb_Clear(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_Clear_i(o,v);
}

void glpUI::cb_Open_i(Fl_Menu_*, void*) {
  Fl_File_Icon::load_system_icons();

pout->xoffsets ( 0.05, 0.05 );
pout->yoffsets ( 0.05, 0.05 );
pout->xrotation ( 0.0 );
pout->yrotation ( 0.0 );
pout->zrotation ( 0.0 );

char * filename = fl_file_chooser ( "Open File...", 0, 0 );
if ( filename ) {
  if ( _3D ) {
    glp::surface s = glp::surface_from_file ( filename, colsopt, sliceopt );
    if ( _volume ) s.triangulate_spherically ( true );
    *pout << s;
  } else {
    glp::curve c = glp::curve_from_file ( filename, colsopt, sliceopt );
    *pout << c;
  }
}

pout->redraw();
}
void glpUI::cb_Open(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_Open_i(o,v);
}

void glpUI::cb_Save_i(Fl_Menu_*, void*) {
  Fl_File_Icon::load_system_icons();

char * filename = fl_file_chooser ( "Save File...", "All Supported Files(*.{ps,eps,tex,pdf,svg,pgf})", 0 );
if ( filename ) {
  pout->save ( filename );
};
}
void glpUI::cb_Save(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

void glpUI::cb_Exit_i(Fl_Menu_*, void*) {
  exit(0);
}
void glpUI::cb_Exit(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_Exit_i(o,v);
}

void glpUI::cb_Input_i(Fl_Menu_*, void*) {
  input->show();
}
void glpUI::cb_Input(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_Input_i(o,v);
}

void glpUI::cb_dots_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_dots(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_dots_i(o,v);
}

void glpUI::cb_style1_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_style1(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_style1_i(o,v);
}

void glpUI::cb_points_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_points(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_points_i(o,v);
}

void glpUI::cb_linespoints_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_linespoints(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_linespoints_i(o,v);
}

void glpUI::cb_xerrorbars_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_xerrorbars(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_xerrorbars_i(o,v);
}

void glpUI::cb_yerrorbars_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_yerrorbars(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_yerrorbars_i(o,v);
}

void glpUI::cb_xyerrorbars_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_xyerrorbars(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_xyerrorbars_i(o,v);
}

void glpUI::cb_xerrorlines_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_xerrorlines(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_xerrorlines_i(o,v);
}

void glpUI::cb_yerrorlines_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_yerrorlines(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_yerrorlines_i(o,v);
}

void glpUI::cb_xyerrorlines_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_xyerrorlines(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_xyerrorlines_i(o,v);
}

void glpUI::cb_impulses_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_impulses(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_impulses_i(o,v);
}

void glpUI::cb_coloredlines_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_coloredlines(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_coloredlines_i(o,v);
}

void glpUI::cb_style2_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_style2(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_style2_i(o,v);
}

void glpUI::cb_errorbars_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_errorbars(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_errorbars_i(o,v);
}

void glpUI::cb_errorlines_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_errorlines(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_errorlines_i(o,v);
}

void glpUI::cb_lighting_i(Fl_Menu_* o, void*) {
  pout->style ( glp::plot_style ( o->text() ) );
pout->redraw();
}
void glpUI::cb_lighting(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_lighting_i(o,v);
}

void glpUI::cb_logarithmic_i(Fl_Menu_*, void*) {
  pout->xlog ( !pout->xlog() );
pout->redraw();
}
void glpUI::cb_logarithmic(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_logarithmic_i(o,v);
}

void glpUI::cb_logarithmic1_i(Fl_Menu_*, void*) {
  pout->ylog ( !pout->ylog() );
pout->redraw();
}
void glpUI::cb_logarithmic1(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_logarithmic1_i(o,v);
}

void glpUI::cb_logarithmic2_i(Fl_Menu_*, void*) {
  pout->zlog ( !pout->zlog() );
pout->redraw();
}
void glpUI::cb_logarithmic2(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_logarithmic2_i(o,v);
}

void glpUI::cb_autoscale_i(Fl_Menu_*, void*) {
  pout->xoffsets ( 0.05, 0.05 );
pout->yoffsets ( 0.05, 0.05 );
pout->redraw();
}
void glpUI::cb_autoscale(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_autoscale_i(o,v);
}

void glpUI::cb_ticks_i(Fl_Menu_*, void*) {
  pout->ticks_visible ( !pout->ticks_visible() );
pout->redraw();
}
void glpUI::cb_ticks(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_ticks_i(o,v);
}

void glpUI::cb_grid_i(Fl_Menu_*, void*) {
  pout->grid_visible ( !pout->grid_visible() );
pout->redraw();
}
void glpUI::cb_grid(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_grid_i(o,v);
}

void glpUI::cb_key_i(Fl_Menu_*, void*) {
  pout->key_visible ( !pout->key_visible() );
pout->redraw();
}
void glpUI::cb_key(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_key_i(o,v);
}

void glpUI::cb_common_i(Fl_Menu_*, void*) {
  pout->style_visible ( !pout->style_visible() );
pout->redraw();
}
void glpUI::cb_common(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_common_i(o,v);
}

void glpUI::cb_background_i(Fl_Menu_*, void*) {
  double r = pout->background().r();
double g = pout->background().g();
double b = pout->background().b();
if ( fl_color_chooser ( "Background color", r, g, b ) ) {
  pout->background ( glp::color ( r, g, b ) );
};
}
void glpUI::cb_background(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_background_i(o,v);
}

void glpUI::cb_foreground_i(Fl_Menu_*, void*) {
  double r = (double)pout->foreground().r;
double g = (double)pout->foreground().g;
double b = (double)pout->foreground().b;
if ( fl_color_chooser ( "Foreground color", r, g, b ) ) {
  pout->foreground ( glp::color ( r, g, b ) );
};
}
void glpUI::cb_foreground(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_foreground_i(o,v);
}

void glpUI::cb_negative_i(Fl_Menu_*, void*) {
  pout->negative ( !pout->negative() );
pout->redraw();
}
void glpUI::cb_negative(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_negative_i(o,v);
}

void glpUI::cb_fullscreen_i(Fl_Menu_*, void*) {
  _fullscreen = !_fullscreen;
if ( _fullscreen ) {
  _x4fs = self->x();
  _y4fs = self->y();
  _w4fs = self->w();
  _h4fs = self->h();
  self->fullscreen();
} else {
  self->fullscreen_off ( _x4fs, _y4fs, _w4fs, _h4fs );
};
}
void glpUI::cb_fullscreen(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_fullscreen_i(o,v);
}

void glpUI::cb_clipping_i(Fl_Menu_*, void*) {
  clipping->show();
}
void glpUI::cb_clipping(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_clipping_i(o,v);
}

void glpUI::cb_rainbow_i(Fl_Menu_* o, void*) {
  pout->rgbscheme ( glp::color_scheme ( o->text() ) );
pout->redraw();
}
void glpUI::cb_rainbow(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_rainbow_i(o,v);
}

void glpUI::cb_hot_i(Fl_Menu_* o, void*) {
  pout->rgbscheme ( glp::color_scheme ( o->text() ) );
pout->redraw();
}
void glpUI::cb_hot(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_hot_i(o,v);
}

void glpUI::cb_ocean_i(Fl_Menu_* o, void*) {
  pout->rgbscheme ( glp::color_scheme ( o->text() ) );
pout->redraw();
}
void glpUI::cb_ocean(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_ocean_i(o,v);
}

void glpUI::cb_terrain_i(Fl_Menu_* o, void*) {
  pout->rgbscheme ( glp::color_scheme ( o->text() ) );
pout->redraw();
}
void glpUI::cb_terrain(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_terrain_i(o,v);
}

void glpUI::cb_traditional_i(Fl_Menu_* o, void*) {
  pout->rgbscheme ( glp::color_scheme ( o->text() ) );
pout->redraw();
}
void glpUI::cb_traditional(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_traditional_i(o,v);
}

void glpUI::cb_grayscale_i(Fl_Menu_* o, void*) {
  pout->rgbscheme ( glp::color_scheme ( o->text() ) );
pout->redraw();
}
void glpUI::cb_grayscale(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_grayscale_i(o,v);
}

void glpUI::cb_8x13_i(Fl_Menu_* o, void*) {
  pout->font ( glp::text_font ( o->text() ) );
pout->redraw();
}
void glpUI::cb_8x13(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_8x13_i(o,v);
}

void glpUI::cb_9x15_i(Fl_Menu_* o, void*) {
  pout->font ( glp::text_font ( o->text() ) );
pout->redraw();
}
void glpUI::cb_9x15(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_9x15_i(o,v);
}

void glpUI::cb_helvetica_i(Fl_Menu_* o, void*) {
  pout->font ( glp::text_font ( o->text() ) );
pout->redraw();
}
void glpUI::cb_helvetica(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_helvetica_i(o,v);
}

void glpUI::cb_helvetica1_i(Fl_Menu_* o, void*) {
  pout->font ( glp::text_font ( o->text() ) );
pout->redraw();
}
void glpUI::cb_helvetica1(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_helvetica1_i(o,v);
}

void glpUI::cb_helvetica2_i(Fl_Menu_* o, void*) {
  pout->font ( glp::text_font ( o->text() ) );
pout->redraw();
}
void glpUI::cb_helvetica2(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_helvetica2_i(o,v);
}

void glpUI::cb_times_i(Fl_Menu_* o, void*) {
  pout->font ( glp::text_font ( o->text() ) );
pout->redraw();
}
void glpUI::cb_times(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_times_i(o,v);
}

void glpUI::cb_times1_i(Fl_Menu_* o, void*) {
  pout->font ( glp::text_font ( o->text() ) );
pout->redraw();
}
void glpUI::cb_times1(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_times1_i(o,v);
}

void glpUI::cb_About_i(Fl_Menu_*, void*) {
  string msg;
#ifdef HAVE_CONFIG_H
#include <config.h>
msg += PACKAGE;
msg += " ";
msg += VERSION;
msg += "\n";
#else
msg += "Author:\n";
#endif
msg += "(c) 2004-2007, Alexei Soloviev";
msg += "\n";
msg += "solovjev@@cv.jinr.ru";
fl_message ( msg.c_str() );
}
void glpUI::cb_About(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_About_i(o,v);
}

void glpUI::cb_Manual_i(Fl_Menu_*, void*) {
  #ifdef HAVE_CONFIG_H
#include <config.h>

const char * docdir;

if ((docdir = getenv("DOCDIR")) == NULL) {
  docdir = DOCDIR;
}

char helpname[1024];
snprintf(helpname, sizeof(helpname), "%s/%s", docdir, "index.html");  

static Fl_Help_Dialog help_dialog;
help_dialog.load(helpname);
help_dialog.show();

#endif
}
void glpUI::cb_Manual(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_Manual_i(o,v);
}

Fl_Menu_Item glpUI::menu_[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Clear", 0,  (Fl_Callback*)glpUI::cb_Clear, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open...", 0,  (Fl_Callback*)glpUI::cb_Open, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save...", 0,  (Fl_Callback*)glpUI::cb_Save, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Exit", 0xff1b,  (Fl_Callback*)glpUI::cb_Exit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Input...", 0,  (Fl_Callback*)glpUI::cb_Input, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Style", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"dots", 0,  (Fl_Callback*)glpUI::cb_dots, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"lines", 0,  (Fl_Callback*)glpUI::cb_style1, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"points", 0,  (Fl_Callback*)glpUI::cb_points, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"linespoints", 0,  (Fl_Callback*)glpUI::cb_linespoints, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"xerrorbars", 0,  (Fl_Callback*)glpUI::cb_xerrorbars, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"yerrorbars", 0,  (Fl_Callback*)glpUI::cb_yerrorbars, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"xyerrorbars", 0,  (Fl_Callback*)glpUI::cb_xyerrorbars, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"xerrorlines", 0,  (Fl_Callback*)glpUI::cb_xerrorlines, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"yerrorlines", 0,  (Fl_Callback*)glpUI::cb_yerrorlines, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"xyerrorlines", 0,  (Fl_Callback*)glpUI::cb_xyerrorlines, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"impulses", 0,  (Fl_Callback*)glpUI::cb_impulses, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"coloredlines", 0,  (Fl_Callback*)glpUI::cb_coloredlines, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"colormap", 0,  (Fl_Callback*)glpUI::cb_style2, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"errorbars", 0,  (Fl_Callback*)glpUI::cb_errorbars, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"errorlines", 0,  (Fl_Callback*)glpUI::cb_errorlines, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"lighting", 0,  (Fl_Callback*)glpUI::cb_lighting, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Scale", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"logarithmic scale for x-axis", 0x78,  (Fl_Callback*)glpUI::cb_logarithmic, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"logarithmic scale for y-axis", 0x79,  (Fl_Callback*)glpUI::cb_logarithmic1, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"logarithmic scale for z-axis", 0x7a,  (Fl_Callback*)glpUI::cb_logarithmic2, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Decor", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"autoscale", 0x61,  (Fl_Callback*)glpUI::cb_autoscale, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"ticks", 0x74,  (Fl_Callback*)glpUI::cb_ticks, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"grid", 0x67,  (Fl_Callback*)glpUI::cb_grid, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"key", 0x6b,  (Fl_Callback*)glpUI::cb_key, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"common style", 0x63,  (Fl_Callback*)glpUI::cb_common, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"background...", 0,  (Fl_Callback*)glpUI::cb_background, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"foreground...", 0,  (Fl_Callback*)glpUI::cb_foreground, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"negative", 0x6e,  (Fl_Callback*)glpUI::cb_negative, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"fullscreen", 0x66,  (Fl_Callback*)glpUI::cb_fullscreen, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"clipping...", 0,  (Fl_Callback*)glpUI::cb_clipping, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Color", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"rainbow", 0,  (Fl_Callback*)glpUI::cb_rainbow, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"hot", 0,  (Fl_Callback*)glpUI::cb_hot, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"ocean", 0,  (Fl_Callback*)glpUI::cb_ocean, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"terrain", 0,  (Fl_Callback*)glpUI::cb_terrain, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"traditional", 0,  (Fl_Callback*)glpUI::cb_traditional, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"grayscale", 0,  (Fl_Callback*)glpUI::cb_grayscale, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Font", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"8x13", 0,  (Fl_Callback*)glpUI::cb_8x13, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"9x15", 0,  (Fl_Callback*)glpUI::cb_9x15, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"helvetica-10", 0,  (Fl_Callback*)glpUI::cb_helvetica, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"helvetica-12", 0,  (Fl_Callback*)glpUI::cb_helvetica1, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"helvetica-18", 0,  (Fl_Callback*)glpUI::cb_helvetica2, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"times-roman-10", 0,  (Fl_Callback*)glpUI::cb_times, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {"times-roman-24", 0,  (Fl_Callback*)glpUI::cb_times1, 0, 8, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Help", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"About...", 0,  (Fl_Callback*)glpUI::cb_About, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Manual...", 0,  (Fl_Callback*)glpUI::cb_Manual, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* glpUI::style1 = glpUI::menu_ + 9;
Fl_Menu_Item* glpUI::style2 = glpUI::menu_ + 20;

void glpUI::cb_3D_i(Fl_Menu_*, void*) {
  _3D = !_3D;
if ( _3D ) {
  vol->activate();
  style2->setonly();
  pout->style ( glp::plot_style ( style2->label() ) );
  pout->redraw();
} else {
  vol->deactivate();
  style1->setonly();
  pout->style ( glp::plot_style ( style1->label() ) );
  pout->redraw();
};
}
void glpUI::cb_3D(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_3D_i(o,v);
}

void glpUI::cb_vol_i(Fl_Menu_*, void*) {
  _volume = !_volume;
}
void glpUI::cb_vol(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_vol_i(o,v);
}

Fl_Menu_Item glpUI::menu_1[] = {
 {"3D", 0x33,  (Fl_Callback*)glpUI::cb_3D, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {"Volume", 0x33,  (Fl_Callback*)glpUI::cb_vol, 0, 3, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* glpUI::vol = glpUI::menu_1 + 1;

void glpUI::cb_OK_i(Fl_Return_Button*, void*) {
  if ( icols->value() && icols->value() != "" ) {
  const string str ( icols->value() );
  const unsigned int waste = count_if ( str.begin(), str.end(), not1 ( ptr_fun ( ::isdigit ) ) );
  static const char delimiter = ':';
  unsigned int ncols = count ( str.begin(), str.end(), delimiter );
  if ( ncols == waste ) ++ncols;
  else ncols = 0;
  if ( _3D ) {
    if ( ncols != 3 && ncols != 6 ) {
      fl_message ( "Columns: expecting 'x:y:z' or 'x:y:z:dx:dy:dz'" );
      return;
    }
  } else {
    if ( ncols < 1 || ncols > 4 ) {
      fl_message ( "Columns: expecting 'x:y', 'x:y:dy', 'x:y:dy:dx' or just 'y'" );
      return;
    }
  }
  colsopt = icols->value();
}

if ( islice->value() && islice->value() != "" ) {
  const string str ( islice->value() );
  const unsigned int waste = count_if ( str.begin(), str.end(), not1 ( ptr_fun ( ::isdigit ) ) );
  static const char delimiter = ':';
  unsigned int ncols = count ( str.begin(), str.end(), delimiter );
  if ( ncols == waste ) ++ncols;
  else ncols = 0;
  if ( ncols != 3 ) {
    fl_message ( "Lines: expecting 'from:to:stride'" );
    return;
  }
  sliceopt = islice->value();
}

input->hide();
}
void glpUI::cb_OK(Fl_Return_Button* o, void* v) {
  ((glpUI*)(o->parent()->parent()->user_data()))->cb_OK_i(o,v);
}

void glpUI::cb_Cancel_i(Fl_Button*, void*) {
  icols->value(colsopt);
islice->value(sliceopt);
input->hide();
}
void glpUI::cb_Cancel(Fl_Button* o, void* v) {
  ((glpUI*)(o->parent()->parent()->user_data()))->cb_Cancel_i(o,v);
}

void glpUI::cb_Clear1_i(Fl_Button*, void*) {
  icols->value(0);
islice->value(0);
}
void glpUI::cb_Clear1(Fl_Button* o, void* v) {
  ((glpUI*)(o->parent()->parent()->user_data()))->cb_Clear1_i(o,v);
}

void glpUI::cb_Clipping_i(Fl_Menu_*, void*) {
  _clipping = !_clipping;
}
void glpUI::cb_Clipping(Fl_Menu_* o, void* v) {
  ((glpUI*)(o->parent()->user_data()))->cb_Clipping_i(o,v);
}

Fl_Menu_Item glpUI::menu_2[] = {
 {"Clipping", 0,  (Fl_Callback*)glpUI::cb_Clipping, 0, 2, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0}
};

void glpUI::cb_OK1_i(Fl_Return_Button*, void*) {
  glp::point dir1, dir2, dir3, dir4, dir5;
double pos1, pos2, pos3, pos4, pos5;

clipplane1 = clip1->value();
clipplane2 = clip2->value();
clipplane3 = clip3->value();
clipplane4 = clip4->value();
clipplane5 = clip5->value();

if ( clipplane1 && clipplane1 != "" ) {
  glp::plane_from_str ( clipplane1, dir1, pos1 );
  pout->clip ( dir1, pos1 );
}
if ( clipplane2 && clipplane2 != "" ) {
  glp::plane_from_str ( clipplane2, dir2, pos2 );
  pout->clip ( dir2, pos2 );
}
if ( clipplane3 && clipplane3 != "" ) {
  glp::plane_from_str ( clipplane3, dir3, pos3 );
  pout->clip ( dir3, pos3 );
}
if ( clipplane4 && clipplane4 != "" ) {
  glp::plane_from_str ( clipplane4, dir4, pos4 );
  pout->clip ( dir4, pos4 );
}
if ( clipplane5 && clipplane5 != "" ) {
  glp::plane_from_str ( clipplane5, dir5, pos5 );
  pout->clip ( dir5, pos5 );
}

pout->clipping(_clipping);

clipping->hide();
}
void glpUI::cb_OK1(Fl_Return_Button* o, void* v) {
  ((glpUI*)(o->parent()->parent()->user_data()))->cb_OK1_i(o,v);
}

void glpUI::cb_Cancel1_i(Fl_Button*, void*) {
  clipping->hide();
}
void glpUI::cb_Cancel1(Fl_Button* o, void* v) {
  ((glpUI*)(o->parent()->parent()->user_data()))->cb_Cancel1_i(o,v);
}

void glpUI::cb_Clear2_i(Fl_Button*, void*) {
  clip1->value(0);
clip2->value(0);
clip3->value(0);
clip4->value(0);
clip5->value(0);
}
void glpUI::cb_Clear2(Fl_Button* o, void* v) {
  ((glpUI*)(o->parent()->parent()->user_data()))->cb_Clear2_i(o,v);
}
#ifdef WIN32
#include "gluplotrc.h"
#endif
#if !defined (WIN32) && !defined(__APPLE__)
#ifdef HAVE_XPM
#include "gluplot.xpm"
#include <X11/xpm.h>
#endif
#ifndef HAVE_XPM
#include "gluplot.xbm"
#endif
#endif
#include <FL/x.H>

glpUI::glpUI() {
  Fl_Double_Window* w;
  _3D = _volume = false;
colsopt = 0;
sliceopt = 0;
_fullscreen = false;
_clipping = false;
clipplane1 = clipplane2 = clipplane3 = clipplane4 = clipplane5 = 0;
  { Fl_Double_Window* o = self = new Fl_Double_Window(640, 505);
    w = o;
    o->user_data((void*)(this));
    { fluplot* o = pout = new fluplot(0, 25, 640, 480);
      o->box(FL_NO_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor(FL_FOREGROUND_COLOR);
      o->align(FL_ALIGN_TOP);
      o->when(FL_WHEN_CHANGED);
      o->end();
      Fl_Group::current()->resizable(o);
    }
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 640, 25);
      { Fl_Menu_Item* o = &menu_[9];
        o->setonly();
      }
      { Fl_Menu_Item* o = &menu_[43];
        o->set();
      }
      { Fl_Menu_Item* o = &menu_[54];
        o->setonly();
      }
      o->menu(menu_);
    }
    self->label("The Gluplot Plotting Package");
    o->end();
  }
  { Fl_Double_Window* o = input = new Fl_Double_Window(220, 105, "Input");
    w = o;
    o->user_data((void*)(this));
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 220, 24);
      o->box(FL_FLAT_BOX);
      o->menu(menu_1);
    }
    { Fl_Group* o = new Fl_Group(0, 26, 427, 49);
      { Fl_Input* o = icols = new Fl_Input(65, 26, 150, 24, "Columns:");
        o->value(colsopt);
      }
      { Fl_Input* o = islice = new Fl_Input(65, 51, 150, 24, "Lines:");
        o->value(sliceopt);
      }
      o->end();
    }
    { Fl_Group* o = new Fl_Group(5, 75, 210, 25);
      { Fl_Return_Button* o = new Fl_Return_Button(151, 80, 64, 20, "OK");
        o->shortcut(0xff0d);
        o->callback((Fl_Callback*)cb_OK);
      }
      { Fl_Button* o = new Fl_Button(81, 80, 64, 20, "Cancel");
        o->shortcut(0xff1b);
        o->callback((Fl_Callback*)cb_Cancel);
      }
      { Fl_Button* o = new Fl_Button(10, 80, 64, 20, "Clear");
        o->shortcut(0xffff);
        o->callback((Fl_Callback*)cb_Clear1);
      }
      o->end();
    }
    o->set_modal();
    o->end();
  }
  { Fl_Double_Window* o = clipping = new Fl_Double_Window(325, 180, "Clipping");
    w = o;
    o->user_data((void*)(this));
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 370, 20);
      o->box(FL_FLAT_BOX);
      o->menu(menu_2);
    }
    { Fl_Group* o = new Fl_Group(110, 150, 210, 25);
      { Fl_Return_Button* o = new Fl_Return_Button(256, 155, 64, 20, "OK");
        o->shortcut(0xff0d);
        o->callback((Fl_Callback*)cb_OK1);
      }
      { Fl_Button* o = new Fl_Button(186, 155, 64, 20, "Cancel");
        o->shortcut(0xff1b);
        o->callback((Fl_Callback*)cb_Cancel1);
      }
      { Fl_Button* o = new Fl_Button(115, 155, 64, 20, "Clear");
        o->shortcut(0xffff);
        o->callback((Fl_Callback*)cb_Clear2);
      }
      o->end();
    }
    { Fl_Group* o = new Fl_Group(0, 27, 320, 123);
      { Fl_Input* o = clip1 = new Fl_Input(100, 27, 220, 23, "clipping plane:");
        o->value(clipplane1);
      }
      { Fl_Input* o = clip2 = new Fl_Input(100, 51, 220, 24, "clipping plane:");
        o->value(clipplane2);
      }
      { Fl_Input* o = clip3 = new Fl_Input(100, 76, 220, 24, "clipping plane:");
        o->value(clipplane3);
      }
      { Fl_Input* o = clip4 = new Fl_Input(100, 101, 220, 24, "clipping plane:");
        o->value(clipplane4);
      }
      { Fl_Input* o = clip5 = new Fl_Input(100, 126, 220, 24, "clipping plane:");
        o->value(clipplane5);
      }
      o->end();
    }
    o->set_modal();
    o->end();
  }
  // Set icon for window (MacOS uses app bundle for icon...)
#ifdef WIN32
  self->icon((char *)LoadIcon(fl_display, MAKEINTRESOURCE(IDI_ICON)));
#elif !defined(__APPLE__)
  fl_open_display();
#ifdef HAVE_XPM
  Pixmap p, mask;
  XpmCreatePixmapFromData(fl_display, DefaultRootWindow(fl_display),
                          gluplot_xpm, &p, &mask, NULL);
#else // HAVE_XPM
  Pixmap p = XCreateBitmapFromData(fl_display, DefaultRootWindow(fl_display),
                                   (char *)gluplot_bits, gluplot_width, gluplot_height);
#endif // HAVE_XPM
  self->icon((char *)p);
#endif // WIN32
}

void glpUI::show(int argc, char**argv) {
  self->show(argc,argv);
}
